# データベース層のチューニング

データベースはパフォーマンスのボトルネックになりやすい箇所です。基本的な考え方を学びます。

---

```
┌─────────────────────────────────────────────────────────────┐
│              「DBが遅いんだけど」                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  パフォーマンス問題の犯人として真っ先に疑われるDB。         │
│  実際、ボトルネックになっていることも多い。                 │
│                                                             │
│  でも「DBが遅い」で終わらせていないか？                     │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・どのクエリが遅い？（スロークエリログ）            │   │
│  │ ・なぜ遅い？（EXPLAIN）                             │   │
│  │ ・インデックス使ってる？（実行計画）                │   │
│  │ ・接続で待ってない？（接続プール）                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  「DBが遅い」を「このクエリのこの部分が遅い」に分解する     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## このレイヤーのキー要素

```
┌─────────────────────────────────────────────────────────────┐
│              データベース層で押さえるべきポイント            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│  │インデックス│  │クエリ最適化│  │接続プール│  │トランザクション│   │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘       │
│       │            │            │            │             │
│       ↓            ↓            ↓            ↓             │
│   O(N)→O(logN)  EXPLAINで    接続確立     ロック時間を    │
│   に高速化      実行計画確認  コスト削減   最小化          │
│                                                             │
│  まず: スロークエリログ → EXPLAIN → インデックス検討       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## データベースのボトルネック

```
┌─────────────────────────────────────────────────────────────┐
│              よくある問題                                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  クエリの問題:                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・フルテーブルスキャン                              │   │
│  │ ・非効率なJOIN                                      │   │
│  │ ・不要なカラムの取得（SELECT *）                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  インデックスの問題:                                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・インデックスがない                                │   │
│  │ ・インデックスが使われていない                      │   │
│  │ ・インデックスが多すぎて更新が遅い                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  接続の問題:                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・接続プール枯渇                                    │   │
│  │ ・接続のリーク                                      │   │
│  │ ・コネクション数の上限                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ロックの問題:                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・長時間のトランザクション                          │   │
│  │ ・デッドロック                                      │   │
│  │ ・ロック競合                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## クエリの最適化

### 実行計画を読む

```
┌─────────────────────────────────────────────────────────────┐
│              EXPLAINで確認する                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  EXPLAIN ANALYZE SELECT * FROM users WHERE email = '...';   │
│                                                             │
│  見るべきポイント:                                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                                                     │   │
│  │ Seq Scan（シーケンシャルスキャン）:                 │   │
│  │   テーブル全体を読む → インデックスが必要かも      │   │
│  │                                                     │   │
│  │ Index Scan / Index Only Scan:                       │   │
│  │   インデックスを使っている → 良い                  │   │
│  │                                                     │   │
│  │ Nested Loop:                                        │   │
│  │   小さいテーブル同士なら良い、大きいと遅い          │   │
│  │                                                     │   │
│  │ Hash Join:                                          │   │
│  │   大きいテーブル同士で効率的                        │   │
│  │                                                     │   │
│  │ Sort:                                               │   │
│  │   ソートが必要 → インデックスで回避できるか        │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  actual time と rows を確認:                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 見積もり(rows)と実際(actual)が大きく違う場合        │   │
│  │ → 統計情報が古い → ANALYZE を実行                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### スロークエリの発見

```
┌─────────────────────────────────────────────────────────────┐
│              スロークエリログを活用                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  PostgreSQL:                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ log_min_duration_statement = 100  # 100ms以上を記録 │   │
│  │ pg_stat_statements          # クエリ統計           │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  MySQL:                                                     │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ slow_query_log = ON                                 │   │
│  │ long_query_time = 0.1       # 100ms以上を記録      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  分析のポイント:                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・実行回数 × 平均時間 = 影響度                      │   │
│  │ ・1回は速いが大量に実行されるクエリも要注意        │   │
│  │ ・N+1問題のパターンを探す                           │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## インデックス

スロークエリを見つけて、EXPLAINで確認したら Seq Scan（フルスキャン）が出た。インデックスがない？使われていない？

ここでインデックスの基本をおさらいしておこう。

### インデックスの基本

```
┌─────────────────────────────────────────────────────────────┐
│              インデックスは「目次」                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  インデックスなし（フルスキャン）:                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 1ページ目から順番に探す                             │   │
│  │ 100万件あれば最悪100万件見る                        │   │
│  │ O(N)                                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  インデックスあり（B-Tree）:                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 目次を見て該当ページに直行                          │   │
│  │ 100万件でも数回の比較で到達                         │   │
│  │ O(log N)                                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  インデックスを作るべき列:                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・WHERE句で頻繁に使われる列                         │   │
│  │ ・JOINの結合条件に使われる列                        │   │
│  │ ・ORDER BYで使われる列                              │   │
│  │ ・カーディナリティ（値の種類）が高い列              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  インデックスの種類（PostgreSQL）:                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ B-Tree:  一般的な検索、範囲検索、ORDER BY（デフォルト）│  │
│  │ Hash:    等価検索のみ（=）、範囲検索には使えない    │   │
│  │ GIN:     配列、JSONB、全文検索                      │   │
│  │ GiST:    地理データ、範囲型、全文検索               │   │
│  │ BRIN:    時系列など物理的に順序が揃ったデータ       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  用途とデータ量で選ぶ:                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・JSONBの中身を検索 → B-Treeではなく GIN            │   │
│  │ ・等価検索のみ → Hash の方が速い場合も              │   │
│  │ ・時系列データで数億件 → BRIN で省メモリ化          │   │
│  │ ・小さいテーブル → インデックス不要な場合も         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  インデックスのコスト:                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・ディスク容量を消費する                            │   │
│  │ ・INSERT/UPDATE/DELETE が遅くなる                   │   │
│  │ ・データ量が少ないとSeq Scanの方が速い場合も        │   │
│  │ → 闇雲に作らない、効果を計測する                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### データ量と性能

開発環境では速いのに本番で遅い。データ量によって性能は劇的に変わる。

#### データ量と検索性能の比較

**データ量による性能差（目安）**

| 方式 | 1,000件 | 100万件 | 計算量 |
|------|---------|---------|--------|
| Seq Scan | 1ms | 1,000ms | O(N) |
| B-Tree | 0.1ms | 0.3ms | O(log N) |
| Hash | 0.05ms | 0.06ms | O(1) |
| GIN（10件ヒット） | 1ms | 2ms | ヒット件数依存 |
| GIN（1000件ヒット） | 5ms | 50ms | ヒット件数依存 |

※ 目安。実際はデータ、クエリ、ハードウェアによる。

**インデックス種類別の特性**

| 方式 | 検索性能 | 更新性能 | 用途・注意点 |
|------|----------|----------|--------------|
| B-Tree | O(log N) 緩やかに劣化 | ○ | 汎用的、更新多いと断片化→REINDEX |
| Hash | O(1) 理論上最速 | ○ | 等価検索のみ、範囲検索不可 |
| GIN | ヒット件数に依存 | △ 重い | JSONB/全文検索用、大量ヒットで遅い |
| BRIN | ○ 大量データ向け | ◎ 軽い | 物理順序が揃っていないと効果薄 |

#### CPU負荷とクエリ性能

クエリ自体が速くても、CPU負荷が高いとスケジューリング待ちで遅延する。

| CPU負荷 | クエリ処理 | 待ち時間 | 実際の応答時間 |
|---------|-----------|----------|----------------|
| 30% | 1ms | ほぼなし | 1ms |
| 70% | 1ms | 1-2ms | 2-3ms |
| 100% | 1ms | 10ms+ | 10ms+ |

インデックス種類によってCPU依存度が異なる：

| 方式 | CPU使用 | I/O使用 | CPU高負荷時の影響 |
|------|---------|---------|-------------------|
| B-Tree | 低（比較のみ） | 高 | 比較的影響少 |
| Hash | 中（ハッシュ計算） | 低 | やや影響あり |
| GIN | 高（トークン処理、ビットマップ演算） | 中 | 影響大 |
| BRIN | 低（サマリー比較） | 高 | 影響少 |

- **B-Tree/BRIN**: I/Oバウンド → CPU高負荷でも比較的安定
- **GIN**: CPUバウンド → CPU高負荷で大きく劣化

#### よくある落とし穴

- 開発環境の少量データでは問題に気づかない
- 本番リリース後にデータが増えて初めて発覚
- 「先週まで速かったのに」→ データ量が閾値を超えた

#### 対策

- 本番相当のデータ量でテストする
- 将来のデータ増加を見越した設計
- 定期的にスロークエリログを確認

### インデックスが使われない場合

```
┌─────────────────────────────────────────────────────────────┐
│              インデックスが効かないパターン                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  関数を使っている:                                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ❌ WHERE LOWER(email) = 'test@example.com'          │   │
│  │ ✅ WHERE email = 'test@example.com'                 │   │
│  │    （または関数インデックスを作成）                 │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  型が違う:                                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ❌ WHERE user_id = '123'  （user_idがINTの場合）    │   │
│  │ ✅ WHERE user_id = 123                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  LIKE前方一致以外:                                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ✅ WHERE name LIKE 'test%'    （前方一致）          │   │
│  │ ❌ WHERE name LIKE '%test'    （後方一致）          │   │
│  │ ❌ WHERE name LIKE '%test%'   （中間一致）          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  複合インデックスの順序:                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ INDEX (a, b, c) がある場合:                         │   │
│  │ ✅ WHERE a = 1                                      │   │
│  │ ✅ WHERE a = 1 AND b = 2                            │   │
│  │ ❌ WHERE b = 2         （最初の列がない）           │   │
│  │ ❌ WHERE b = 2 AND c = 3                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 接続プール

```
┌─────────────────────────────────────────────────────────────┐
│              接続プールの設計                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  接続数の見積もり（リトルの法則）:                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 必要接続数 = リクエストレート × DB処理時間          │   │
│  │                                                     │   │
│  │ 例: 100 req/sec × 0.05 sec = 5 接続                 │   │
│  │ 余裕を見て 2〜3倍 = 10〜15 接続                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  多すぎる接続の問題:                                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・DBサーバーのメモリ消費（1接続 = 数MB）            │   │
│  │ ・コンテキストスイッチのオーバーヘッド              │   │
│  │ ・接続数に比例して性能が上がるわけではない          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  PgBouncerなどの接続プロキシ:                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・アプリ側の接続を少ないDB接続で多重化              │   │
│  │ ・接続確立のオーバーヘッドを削減                    │   │
│  │ ・多数のアプリサーバーがある場合に有効              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## トランザクションとロック

```
┌─────────────────────────────────────────────────────────────┐
│              トランザクションは短く                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  長いトランザクションの問題:                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・ロックを長時間保持 → 他のクエリがブロック         │   │
│  │ ・接続を長時間占有 → 接続プール枯渇                │   │
│  │ ・ロールバック時のコスト増大                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  対策:                                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・トランザクション内で外部API呼び出しをしない       │   │
│  │ ・必要最小限の範囲でトランザクションを使う          │   │
│  │ ・バッチ処理は小さな単位に分割                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ロック競合を減らす:                                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ ・楽観的ロック（バージョン番号）の活用              │   │
│  │ ・ロックの順序を統一（デッドロック防止）            │   │
│  │ ・READ COMMITTEDで十分な場合はそれを使う            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## パーティショニング

データ量が増えすぎたテーブルは、パーティショニング（テーブル分割）を検討する。

#### いつ検討すべきか

| 状況 | 検討 |
|------|------|
| テーブルが数千万件を超えた | ◎ 検討すべき |
| 古いデータの削除が遅い | ◎ パーティション単位で削除可能 |
| 時系列データで特定期間のみ参照 | ◎ 日付でパーティション |
| 全件を頻繁にスキャンする | △ 効果薄い |
| テーブルが数百万件程度 | △ インデックスで十分な場合が多い |

#### パーティショニングのトレードオフ

- **メリット**: 古いデータの削除が高速、特定パーティションのみスキャン
- **デメリット**: 設計が複雑化、パーティションキーを跨ぐクエリは遅い

**注意**: 既存テーブルを後からパーティション化することはできない。新しいパーティションテーブルを作成してデータを移行する必要がある。設計段階で検討すべき。

詳細は [PostgreSQL パーティショニング](../11-postgresql/dba-07-partitioning.md) を参照。

---

## ページネーションと大量データ検索

データが蓄積されるテーブル（イベントログ、監査ログ等）では、一覧APIのページネーション設計がボトルネックになる。

### いつから気にすべきか

「データ量が増えたら遅くなる」と言われても、具体的にどこから問題になるのかが分からないと判断できない。

重要なのは**テーブルの総行数ではなく、WHERE条件にヒットする行数**。1億行のテーブルでも、条件で100行に絞れるなら問題ない。COUNT(*)は「ヒットした行を全部数える」ので、ヒット行数が多いほど遅くなる。

```
┌──────────────────────────────────────────────────────────────────────┐
│          パフォーマンスが問題になる目安                                │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  【COUNT(*)】 ← ヒット行数に依存                                     │
│                                                                      │
│  ヒット行数        COUNT(*)応答時間    体感                          │
│  ─────────────────────────────────────────────────                   │
│  〜1万             〜5ms               気にならない                  │
│  1万〜10万         5ms〜50ms           許容範囲                      │
│  10万〜100万       50ms〜500ms         遅さを感じ始める ← ここから注意│
│  100万〜           500ms〜             明確に遅い → 対策必須         │
│                                                                      │
│  例: 1,000万行テーブル、テナントに50万行 → COUNT(*)に1,400ms         │
│  例: 1,000万行テーブル、テナントに1,000行 → COUNT(*)に3ms            │
│                                                                      │
│  【OFFSET】 ← スキップ行数に依存                                     │
│                                                                      │
│  OFFSET値           応答時間           体感                          │
│  ─────────────────────────────────────────────────                   │
│  〜1,000            〜5ms              気にならない                  │
│  1,000〜10,000      5ms〜50ms          許容範囲                      │
│  10,000〜100,000    50ms〜500ms        遅さを感じ始める              │
│  100,000〜          500ms〜            明確に遅い → 対策必須         │
│                                                                      │
│  ページ送りのUIなら問題にならないことが多い。                        │
│  CSVエクスポートなど全件取得で深いOFFSETが発生する。                 │
│                                                                      │
│  【判断のポイント】                                                  │
│  ・今のデータ量ではなく、1年後・3年後のデータ量で考える              │
│  ・ログ系テーブルは月100万行ペースで増えることも珍しくない           │
│  ・初期リリース時は問題なくても、運用が続くと顕在化する              │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### COUNT(*) の罠

```
┌─────────────────────────────────────────────────────────────┐
│              COUNT(*) が遅い理由                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  一覧APIでよくあるパターン:                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ [1] SELECT COUNT(*) ...  → 総件数を取得（遅い）     │   │
│  │ [2] SELECT ... LIMIT 20  → データを取得（速い）     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  COUNT(*)は条件に一致する全行をスキャンする。               │
│  インデックスがあっても50万行ヒットすれば50万行読む。       │
│                                                             │
│  10万件テーブル → 気にならない                              │
│  100万件テーブル → 遅くなり始める                           │
│  1,000万件テーブル → COUNT(*)だけで1秒以上                  │
│                                                             │
│  全体の99%がCOUNT(*)の時間、という状況が起こる。            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 解決策: LIMIT + 1 パターン

「正確な総件数」が不要なら、`LIMIT + 1`で**次ページの有無**だけを判定する。

```
┌─────────────────────────────────────────────────────────────┐
│              LIMIT + 1 パターン                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  要求: limit=20                                             │
│  SQL:  SELECT ... LIMIT 21  (limit + 1)                     │
│                                                             │
│  21件返った → has_more: true（20件返して1件破棄）           │
│  15件返った → has_more: false（15件そのまま返す）           │
│                                                             │
│  COUNT(*) + SELECT:  1,400ms（50万行スキャン + 20行取得）   │
│  LIMIT + 1:          2ms（最大21行だけ読む）                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 解決策: キーセットページネーション

OFFSETはスキップする行を**実際に読み飛ばす**ため、深いページほど遅くなる。

```
┌─────────────────────────────────────────────────────────────┐
│           OFFSET vs キーセットページネーション                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  OFFSET方式:                                                │
│    1ページ目: 2ms                                           │
│    100ページ目: 50ms（2,000行読んで1,980行捨てる）          │
│    10,000ページ目: 2,000ms                                  │
│                                                             │
│  キーセット方式:                                            │
│    全ページ: 2ms（前ページ最後の値をWHERE条件に使う）       │
│                                                             │
│  SQL:                                                       │
│    WHERE (created_at, id) < (前ページ最後の値)              │
│    ORDER BY created_at DESC, id DESC                        │
│    LIMIT 21                                                 │
│                                                             │
│  → OFFSETなしで、インデックスから直接スキャン開始           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### データ量に対する影響の概算イメージ

※ 条件に一致する行数が全体の5%、limit=20、適切なインデックスありの場合の目安。

#### 一覧取得（1ページ目）の応答時間

| テーブル行数 | ヒット行数 | COUNT(*) + SELECT | LIMIT + 1 |
|-------------|-----------|-------------------|-----------|
| 1万 | 500 | 3ms | 2ms |
| 10万 | 5,000 | 15ms | 2ms |
| 100万 | 50,000 | 120ms | 2ms |
| 1,000万 | 500,000 | 1,400ms | 2ms |
| 1億 | 5,000,000 | 15,000ms | 2ms |

COUNT(*)はヒット行数に比例して遅くなる。LIMIT+1はヒット行数に関係なく一定。

#### ページ深度と応答時間（1,000万行テーブル、limit=20）

| ページ | OFFSET値 | OFFSET方式 | キーセット方式 |
|--------|---------|-----------|--------------|
| 1 | 0 | 2ms | 2ms |
| 10 | 180 | 3ms | 2ms |
| 100 | 1,980 | 15ms | 2ms |
| 1,000 | 19,980 | 120ms | 2ms |
| 10,000 | 199,980 | 2,000ms | 2ms |
| 50,000 | 999,980 | 10,000ms+ | 2ms |

OFFSETはスキップ行数に比例して遅くなる。キーセット方式は常に一定。

#### 組み合わせた場合の全体像

```
┌──────────────────────────────────────────────────────────────────────┐
│      手法の組み合わせと応答時間（1,000万行、50万行ヒット）            │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  従来方式（COUNT + OFFSET）:                                         │
│    1ページ目:     COUNT 1,400ms + SELECT 2ms      = 1,402ms          │
│    100ページ目:   COUNT 1,400ms + SELECT 15ms     = 1,415ms          │
│    10,000ページ目: COUNT 1,400ms + SELECT 2,000ms = 3,400ms          │
│                                                                      │
│  改善方式（LIMIT+1 + キーセット）:                                   │
│    1ページ目:     2ms                                                │
│    100ページ目:   2ms                                                │
│    10,000ページ目: 2ms                                               │
│                                                                      │
│  → データ量やページ深度に関係なく一定の応答速度                      │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 適用の判断

| 状況 | 推奨手法 |
|------|----------|
| データ量が少ない（10万行未満） | COUNT(*) + OFFSETで十分 |
| 蓄積テーブル（ログ、イベント等） | LIMIT + 1 で has_more 判定 |
| 深いページングが必要（CSVエクスポート等） | キーセットページネーション |
| UIに正確な総件数が必要 | 上限付きCOUNT or 概算カウント |

詳細は [PostgreSQL 大量データの検索パターン](../11-postgresql/dev-09-large-data-search.md) を参照。

---

## まとめ

```
┌─────────────────────────────────────────────────────────────┐
│              DB チューニングの優先順位                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. スロークエリを見つける                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ スロークエリログ、pg_stat_statementsで特定          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  2. EXPLAINで実行計画を確認                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Seq Scanがあればインデックスを検討                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  3. 適切なインデックスを追加                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ WHERE句、JOIN条件、ORDER BYに対して                 │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  4. クエリを書き換え                                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ N+1解消、不要な列の削除、JOINの見直し               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  5. 接続プール・トランザクションの見直し                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 接続数の調整、トランザクションの短縮                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 次のステップ

- [ネットワーク層](07-network-layer.md) - ネットワークのチューニング

### PostgreSQL詳細

- [クエリ最適化](../11-postgresql/dev-05-query-optimization.md) - クエリの書き方
- [プランナーと統計情報](../11-postgresql/dba-08-planner.md) - 実行計画、統計情報の仕組み
- [インデックス](../11-postgresql/dev-03-indexes.md) - インデックス詳細
- [パーティショニング](../11-postgresql/dba-07-partitioning.md) - テーブル分割
