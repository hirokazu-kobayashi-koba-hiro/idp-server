---
sidebar_position: 2
---

# サービス間通信パターン

---

## 概要

マイクロサービスアーキテクチャでは、サービス間の通信方式が重要な設計要素です。本ドキュメントでは、同期通信と非同期通信のパターン、それぞれの特徴とトレードオフを解説します。

---

## 通信方式の分類

### 同期 vs 非同期

```
┌─────────────────────────────────────────┐
│          同期通信                        │
├─────────────────────────────────────────┤
│  サービスA → リクエスト → サービスB     │
│            ← レスポンス ←               │
│                                         │
│  特徴:                                   │
│  - レスポンスを待つ                     │
│  - 即座に結果が必要な場合に使用         │
│  - 実装がシンプル                       │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│          非同期通信                      │
├─────────────────────────────────────────┤
│  サービスA → メッセージ → キュー        │
│                              ↓          │
│                          サービスB      │
│                          (後で処理)      │
│                                         │
│  特徴:                                   │
│  - レスポンスを待たない                 │
│  - 疎結合                               │
│  - 複雑性が増す                         │
└─────────────────────────────────────────┘
```

---

## 同期通信

### REST API

**基本パターン**:
```
GET    /users/{id}        # ユーザー取得
POST   /users             # ユーザー作成
PUT    /users/{id}        # ユーザー更新
DELETE /users/{id}        # ユーザー削除

通信:
HTTP/1.1 または HTTP/2
データ形式: JSON

利点:
✓ 広く使われている
✓ デバッグが容易
✓ ブラウザから直接テスト可能
✓ ツールサポートが豊富

課題:
⚠ オーバーヘッド（テキストベース）
⚠ スキーマが非明示的
⚠ バージョニングが必要
```

---

### gRPC

**特徴**:
```
Protocol Buffers でスキーマ定義:

// user.proto
service UserService {
  rpc GetUser(GetUserRequest) returns (User);
  rpc CreateUser(CreateUserRequest) returns (User);
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
}

通信:
HTTP/2
データ形式: Protocol Buffers（バイナリ）

利点:
✓ 高速（バイナリ）
✓ 型安全（スキーマ定義）
✓ 双方向ストリーミング
✓ 多言語サポート

課題:
⚠ ブラウザから直接呼び出し困難
⚠ デバッグツールが限定的
⚠ 学習曲線
```

---

### GraphQL

**特徴**:
```
クライアントが必要なデータを指定:

query {
  user(id: "123") {
    name
    email
    posts {
      title
    }
  }
}

利点:
✓ 過不足ないデータ取得
✓ 複数リソースを1リクエストで
✓ 型システム
✓ フロントエンド開発が効率的

課題:
⚠ バックエンドの複雑性
⚠ N+1クエリ問題
⚠ キャッシング戦略が複雑
```

---

## 非同期通信

### メッセージキュー

**Point-to-Point（1対1）**:
```
Producer → Queue → Consumer

例: RabbitMQ

利点:
- メッセージの順序保証
- 確実な配信（ACK）
- 負荷の平準化

用途:
- タスクキュー
- ジョブ処理
```

---

### Pub/Sub（Publish/Subscribe）

**1対多の配信**:
```
Publisher → Topic → Subscriber A
                  → Subscriber B
                  → Subscriber C

例: Apache Kafka, Google Pub/Sub

利点:
- 疎結合
- 複数サービスが同じイベントを処理
- スケーラブル

用途:
- イベント駆動アーキテクチャ
- ログ集約
- リアルタイム分析
```

---

### イベントソーシング

```
状態の変更をイベントとして記録:

イベントストア:
├─ UserCreated (id=123, name=Alice)
├─ EmailUpdated (id=123, email=new@example.com)
└─ UserDeleted (id=123)

現在の状態 = 全イベントの再生結果

利点:
- 完全な監査ログ
- 時間を遡れる
- イベント駆動アーキテクチャとの親和性

課題:
- ストレージ増加
- イベント再生のコスト
- スキーマ進化の管理
```

---

## 通信パターンの選択

### 用途別の推奨

```
リアルタイム応答が必要:
└─ REST API または gRPC

高スループット、バッチ処理:
└─ メッセージキュー

イベント通知、複数サービスへの配信:
└─ Pub/Sub

監査ログ、状態復元が必要:
└─ イベントソーシング
```

---

## サービス間認証

### mTLS（相互TLS）

```
サービスA ←→ 証明書検証 ←→ サービスB

仕組み:
1. サービスA が証明書を提示
2. サービスB が検証
3. サービスB が証明書を提示
4. サービスA が検証
5. 暗号化通信開始

利点:
- 強固な認証
- 通信の暗号化
- サービスメッシュで自動化可能
```

---

### API キー / JWT

```
リクエスト:
Authorization: Bearer <JWT>

サービスB:
1. JWT の署名検証
2. 有効期限確認
3. スコープ確認
4. リクエスト処理

利点:
- 実装がシンプル
- 広く使われている

課題:
- キーの管理
- トークンのローテーション
```

---

## サーキットブレーカーパターン

### 障害の連鎖を防ぐ

```
通常時:
サービスA → サービスB（正常）
           ← レスポンス

障害時:
サービスA → サービスB（エラー）
           ← エラー（繰り返し）

サーキットブレーカー作動:
サービスA → サーキットブレーカー
           → 即座にエラー返却（サービスBを呼ばない）

一定時間後:
└─ 再試行（Half-Open状態）
   └─ 成功 → 回路閉じる
   └─ 失敗 → 回路開いたまま
```

---

**実装例（Resilience4j）**:
```java
@CircuitBreaker(name = "userService", fallbackMethod = "fallback")
public User getUser(String id) {
    return userServiceClient.getUser(id);
}

public User fallback(String id, Exception e) {
    // キャッシュから返す、またはデフォルト値
    return cache.get(id);
}
```

---

## リトライパターン

### 一時的な障害への対応

```
指数バックオフ:

試行1: 即座
試行2: 1秒後
試行3: 2秒後
試行4: 4秒後
試行5: 8秒後
  ↓
最大リトライ回数到達 → エラー

考慮事項:
- 冪等性（同じリクエストを複数回実行しても安全）
- ジッター（リトライタイミングをランダム化）
- タイムアウト設定
```

---

## タイムアウト設定

### 推奨値

```
サービスの種類によって調整:

同期API呼び出し:
├─ 接続タイムアウト: 1-3秒
├─ 読み取りタイムアウト: 5-30秒
└─ 合計: 通常30秒以内

データベースクエリ:
├─ 接続タイムアウト: 5秒
└─ クエリタイムアウト: 10-60秒

外部API:
└─ 保守的に設定（60秒等）

タイムアウト設定の原則:
- デフォルトは短めに
- クリティカルパスは特に短く
- 段階的に緩和
```

---

## まとめ

### 通信方式の選択基準

```
同期通信（REST/gRPC）:
- リアルタイム応答が必要
- シンプルな実装
- 結合度がやや高い

非同期通信（メッセージング）:
- 疎結合が重要
- 高スループット
- 複雑性が増す

実際は両方を組み合わせて使用
```

---

## 次のステップ

- [03-data-management.md](./03-data-management.md) - データ管理戦略
- [04-observability.md](./04-observability.md) - 観測性

---

## 参考リンク

- [gRPC Documentation](https://grpc.io/docs/)
- [Apache Kafka Documentation](https://kafka.apache.org/documentation/)
- [Circuit Breaker Pattern (Martin Fowler)](https://martinfowler.com/bliki/CircuitBreaker.html)

**最終更新**: 2026-01-24
