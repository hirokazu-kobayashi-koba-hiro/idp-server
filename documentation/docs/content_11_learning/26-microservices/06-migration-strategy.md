---
sidebar_position: 6
---

# モノリスからマイクロサービスへの移行戦略

---

## 概要

既存のモノリシックアプリケーションをマイクロサービスへ移行する際の戦略とパターンを解説します。ビッグバン移行のリスクと、段階的移行の実践的アプローチを説明します。

---

## 移行の動機と現実

### なぜ移行するのか

```
よくある動機:

技術的理由:
├─ スケーラビリティの限界
├─ デプロイ頻度の制約
├─ 技術スタックの刷新困難
└─ 肥大化したコードベース

組織的理由:
├─ チームの拡大
├─ 並行開発の困難
├─ リリースの調整コスト
└─ 責任範囲の曖昧さ
```

---

### 移行の現実

```
期待:
「マイクロサービスにすれば全て解決」

現実:
├─ 移行期間: 1-3年
├─ 複雑性の増加
├─ 新たな課題の発生
├─ 一時的なパフォーマンス低下
└─ コストの増加

重要:
移行は手段であって目的ではない
ビジネス価値があるか検証
```

---

## ビッグバン移行 vs 段階的移行

### ビッグバン移行

```
全てを一度に書き換える:

モノリス（現行）
  ↓ 6-12ヶ月開発
マイクロサービス（新規）
  ↓ 一斉切り替え
本番稼働

リスク:
❌ 切り替え失敗のリスク大
❌ ロールバック困難
❌ 長期間フィーチャー凍結
❌ ビッグバン時の混乱
❌ 想定外の問題が一度に発生

成功率: 低い
```

---

### 段階的移行（推奨）

```
少しずつ切り出す:

Phase 1: 通知機能を分離（1-2ヶ月）
  モノリス + 通知サービス

Phase 2: 検索機能を分離（2-3ヶ月）
  モノリス + 通知 + 検索

Phase 3: 注文機能を分離（3-4ヶ月）
  モノリス + 通知 + 検索 + 注文
  ...

数年かけて徐々に移行

リスク:
✓ 各フェーズで検証
✓ ロールバック容易
✓ フィーチャー開発継続
✓ 学習曲線が緩やか

成功率: 高い
```

---

## Strangler Fig パターン

### 概念

```
イチジクが宿主の木を徐々に覆うように、
新システムが旧システムを徐々に置き換える

┌─────────────────────────────────────────┐
│         Strangler Fig パターン           │
├─────────────────────────────────────────┤
│  Phase 1:                               │
│  ┌──────────────────┐                  │
│  │   モノリス        │                  │
│  │  (全機能)        │                  │
│  └──────────────────┘                  │
│                                         │
│  Phase 2:                               │
│  ┌──────────────┐  ┌────┐             │
│  │  モノリス     │  │新   │             │
│  │  (大半)      │  │機能A│             │
│  └──────────────┘  └────┘             │
│                                         │
│  Phase 3:                               │
│  ┌──────────┐  ┌────┐  ┌────┐        │
│  │モノリス   │  │機能A│  │機能B│        │
│  │(縮小)    │  └────┘  └────┘        │
│  └──────────┘                          │
│                                         │
│  Phase N:                               │
│  ┌────┐  ┌────┐  ┌────┐  ┌────┐     │
│  │機能A│  │機能B│  │機能C│  │機能D│     │
│  └────┘  └────┘  └────┘  └────┘     │
│  モノリス消滅                            │
└─────────────────────────────────────────┘
```

---

### 実装パターン

**Proxy/Gateway での切り替え**:
```
┌─────────────────────────────────────────┐
│           Proxy/API Gateway             │
├─────────────────────────────────────────┤
│  ルーティングルール:                     │
│                                         │
│  /users/*    → 新: User Service         │
│  /orders/*   → 新: Order Service        │
│  /products/* → 旧: モノリス              │
│  /reports/*  → 旧: モノリス              │
└─────────────────────────────────────────┘

段階的に新サービスへルーティング追加
```

---

## 移行の優先順位

### どこから切り出すか

**優先度の判断基準**:
```
高優先:
✓ 変更頻度が高い機能
✓ スケーリング要求が高い
✓ 技術スタック刷新したい
✓ 境界が明確
✓ 依存が少ない

低優先:
⚠ 複雑に絡み合った機能
⚠ 変更頻度が低い
⚠ 依存関係が多い
⚠ ドメイン境界が不明確
```

---

**具体例: ECサイト**:
```
Phase 1: 通知サービス
理由:
- 依存が少ない（他から呼ばれるのみ）
- 境界が明確
- 失敗しても影響小
→ 練習に最適

Phase 2: 検索サービス
理由:
- 読み取り専用（書き込みなし）
- データ同期で対応可能
- 独立してスケール可能

Phase 3: 商品カタログ
理由:
- 境界が明確
- 変更頻度が高い
- 在庫管理との分離

Phase N: 注文・決済（最後）
理由:
- クリティカル
- 複雑
- 十分な経験を積んでから
```

---

## 段階的移行の実践手順

### ステップ1: モジュール化（Modular Monolith）

```
移行前の準備:

モノリス内でモジュール境界を明確化:

com.example.monolith
├─ user/           ← 明確な境界
│   ├─ UserService
│   ├─ UserRepository
│   └─ User
├─ order/          ← 明確な境界
│   ├─ OrderService
│   ├─ OrderRepository
│   └─ Order
└─ payment/        ← 明確な境界

ルール:
- モジュール間は public API 経由のみ
- 直接的なDB アクセス禁止
- 疎結合を維持

期間: 3-6ヶ月

効果:
後の切り出しが容易に
```

---

### ステップ2: APIの分離

```
外部向けAPIを整理:

現状（モノリス）:
/api/users/{id}       → モノリス内部
/api/orders/{id}      → モノリス内部
/api/products/{id}    → モノリス内部

API Gateway 導入:
  ↓
/api/users/{id}       → まだモノリス
/api/orders/{id}      → まだモノリス
/api/products/{id}    → まだモノリス

内部実装は変わらないが:
- 外部との境界が明確に
- ルーティングを制御可能に

期間: 1-2ヶ月

準備完了
```

---

### ステップ3: 最初のサービスを切り出し

```
通知サービスの分離:

1. 新サービス開発
   ├─ モノリスのコードを抽出
   ├─ 独立したプロジェクトとして作成
   └─ 独自のDB準備

2. API Gateway でルーティング追加
   /api/notifications/* → 通知サービス

3. モノリスから通知サービスを呼び出すよう修正
   内部呼び出し → HTTP/gRPC 呼び出し

4. テスト
   ├─ 統合テスト
   ├─ E2Eテスト
   └─ 本番同等環境でのテスト

5. 本番デプロイ
   ├─ カナリアリリース（10%のトラフィック）
   ├─ 監視（1週間）
   └─ 全トラフィック切り替え

6. モノリスから通知コード削除

期間: 2-3ヶ月

学び:
- マイクロサービス開発の経験
- デプロイパイプライン構築
- 監視体制の確立
```

---

### ステップ4以降: 繰り返し

```
同じパターンで繰り返し:

Phase 2: 検索サービス（2ヶ月）
Phase 3: 商品サービス（3ヶ月）
Phase 4: 在庫サービス（3ヶ月）
Phase 5: 注文サービス（4ヶ月）
...

ペース:
- 最初は遅い（学習コスト）
- 徐々に加速（ノウハウ蓄積）
- 後半は並行実施可能
```

---

## データ移行の戦略

### パターン1: データベース分離（推奨）

```
ステップ:

1. モノリスDB内でスキーマ分離
   ├─ user_schema
   ├─ order_schema
   └─ product_schema

2. サービス切り出し時に物理分離
   user_schema → user_db (別サーバー)

3. データ同期（移行期間中）
   モノリスDB ⇄ user_db
   └─ 両方を更新（二重書き込み）

4. 完全移行後
   モノリスDB の user_schema 削除

リスク: 低（段階的）
期間: 長め
```

---

### パターン2: イベント駆動での分離

```
1. モノリスがイベント発行
   UserCreated, UserUpdated 等

2. 新サービスがイベントを購読
   自分のDBに保存

3. 新サービスが追いつく
   過去データも同期

4. 読み取りを新サービスに切り替え

5. 書き込みを新サービスに切り替え

6. モノリスのコード削除

利点: データ整合性を保ちやすい
```

---

## 移行期間中の運用

### ハイブリッド構成

```
┌─────────────────────────────────────────┐
│        移行期間中の構成                  │
├─────────────────────────────────────────┤
│  API Gateway                            │
│    ↓                                    │
│  ┌──────────┐  ┌──────────────────┐   │
│  │ モノリス   │  │ マイクロサービス  │   │
│  │          │  │ (3サービス)      │   │
│  │ 機能A    │  │ ├─ 通知          │   │
│  │ 機能B    │  │ ├─ 検索          │   │
│  │ 機能C    │  │ └─ レポート      │   │
│  │ ...      │  │                  │   │
│  └──────────┘  └──────────────────┘   │
│                                         │
│  課題:                                   │
│  ├─ 2つのシステムを並行運用             │
│  ├─ データ同期                          │
│  ├─ デプロイの調整                      │
│  └─ モニタリングの複雑化                │
└─────────────────────────────────────────┘

期間: 1-3年
覚悟: 一時的な複雑さの増加
```

---

## リスク管理

### リスク1: パフォーマンス劣化

**問題**:
```
モノリス内の呼び出し:
メソッド呼び出し（< 1ms）

マイクロサービス間:
HTTP呼び出し（10-100ms）

n回の呼び出し:
モノリス: n ms
マイクロサービス: n × 50ms

レイテンシの増加
```

**対策**:
```
1. APIの粒度を調整
   細かすぎる → 粗くする
   1リクエストで必要なデータを返す

2. キャッシング
   頻繁にアクセスされるデータ
   → Redis等でキャッシュ

3. 非同期化
   即座の応答が不要なら
   → メッセージキューで非同期処理

4. データ複製
   読み取り専用コピーを保持
```

---

### リスク2: データ整合性の問題

**問題**:
```
モノリス:
単一DBトランザクション
→ ACID保証

マイクロサービス:
複数DBにまたがる処理
→ 分散トランザクション

例: 注文処理
注文DB + 在庫DB + 決済DB
原子性の保証が困難
```

**対策**:
```
1. Saga パターン
   補償トランザクションで整合性維持

2. イベントソーシング
   全変更をイベントとして記録
   → 整合性の検証が可能

3. 結果整合性の受容
   即座ではなく、最終的に整合
   ビジネス要件を確認

4. クリティカルな処理はモノリスに残す
   無理に分離しない
```

---

### リスク3: 組織的な混乱

**問題**:
```
技術的な変化だけでなく、組織も変化:

従来:
1つのチームで全機能

移行後:
複数の小チーム
- 調整コストの増加
- 責任範囲の曖昧さ
- コミュニケーションの複雑化
```

**対策**:
```
1. チーム構造を先に整備
   サービス = チーム
   明確な責任範囲

2. API契約の管理
   OpenAPI等で明文化
   破壊的変更の禁止

3. 定期的な同期
   週次の全体ミーティング
   技術的負債の共有

4. 段階的な組織変更
   いきなり全チーム分割しない
```

---

## 移行の判断基準

### 移行すべき状況

```
以下の複数に該当:
✓ チームが20人以上
✓ デプロイが月1回以下（遅い）
✓ 特定機能のスケーリングが必要
✓ コードベースが大きすぎる（100万行以上）
✓ 技術的負債が深刻
✓ 組織がDevOpsに成熟している
```

---

### 移行すべきでない状況

```
以下に該当:
❌ チームが10人以下
❌ スタートアップ（ピボット可能性）
❌ ドメインが流動的
❌ インフラ運用リソース不足
❌ モノリスで十分速い
❌ 「流行っているから」という理由のみ
```

---

### 中間解: Modular Monolith

```
マイクロサービスの利点の一部を享受:

構成:
├─ 単一デプロイメント（シンプル）
├─ モジュール境界が明確（移行準備）
├─ 疎結合（保守性）
└─ 必要になったら分離可能（柔軟性）

多くの場合、これで十分:
- 開発速度が速い
- 運用がシンプル
- 必要になってから分離
```

---

## 移行プロジェクトの計画

### フェーズ分け

**Phase 0: 準備（3-6ヶ月）**:
```
□ ドメインの整理（DDD）
□ モジュール境界の明確化
□ API Gateway 導入
□ モニタリング基盤構築
□ Kubernetes環境準備
□ チーム構成の検討
```

**Phase 1: パイロット（3-4ヶ月）**:
```
□ 最初のサービス切り出し（低リスク）
□ デプロイパイプライン構築
□ 運用手順の確立
□ 学習と改善
```

**Phase 2-N: 本格移行（1-2年）**:
```
□ 優先度順にサービス分離
□ 並行開発（複数チーム）
□ 継続的な改善
```

**Phase N+1: 完了・最適化**:
```
□ モノリス廃止
□ アーキテクチャの最適化
□ 技術的負債の返済
```

---

## 失敗パターンと対策

### 失敗1: 過度な分割

```
失敗例:
50機能 → 50サービス

結果:
- 管理不能
- ネットワークオーバーヘッド大
- 分散モノリス化

対策:
適切な粒度を見極める
5-15サービスから開始
```

---

### 失敗2: ビッグバン移行

```
失敗例:
1年かけて全面書き換え
→ 切り替え日に障害多発

対策:
段階的移行（Strangler Fig）
各ステップで検証
```

---

### 失敗3: 技術先行

```
失敗例:
「マイクロサービスが流行っているから」
→ ビジネス価値を見失う

対策:
ビジネス要件から逆算
ROIを評価
代替案も検討
```

---

### 失敗4: 組織の準備不足

```
失敗例:
技術だけ変更、組織は従来のまま
→ チーム間の調整地獄

対策:
コンウェイの法則を意識
組織構造も同時に変更
```

---

## 成功事例のパターン

### Netflix の移行

```
背景:
- 2008年: モノリス
- データセンター障害で3日間停止

移行:
- 2009-2016年: 段階的にマイクロサービス化
- Strangler Fig パターン
- 数百のマイクロサービス

結果:
- 1日1000回以上のデプロイ
- 高可用性（99.99%）
- グローバルスケール

教訓:
- 7年かけて移行（焦らない）
- ツールも自作（Hystrix等）
- 組織も変革
```

---

### Shopify の選択

```
選択:
モノリスを維持（Modular Monolith）
一部機能のみマイクロサービス化

理由:
- モノリスでも十分速い
- 複雑性を避ける
- 必要な部分のみ分離

結果:
- 高いパフォーマンス維持
- シンプルな運用
- 選択的なマイクロサービス化

教訓:
全てをマイクロサービスにする必要はない
```

---

## 逆方向: マイクロサービスからモノリスへ

### マイクロサービスの失敗

**問題のパターン**:
```
過度なマイクロサービス化の結果:

課題:
├─ ネットワークオーバーヘッド大
├─ デバッグ困難
├─ 運用コスト高
├─ チーム間の調整コスト
└─ パフォーマンス低下

原因:
- 不必要な分割
- 小規模なのにマイクロサービス化
- 流行に乗っただけ
```

---

### 実際の事例

**Amazon Prime Video（2023年）**:
```
背景:
- 動画品質監視システムをマイクロサービスで構築
- 複数のサービス（音声分析、画像分析等）
- サービス間通信が頻繁

問題:
- ネットワークコストが高額
- レイテンシが大きい
- スケーリングの限界

解決:
マイクロサービス → モノリス化
  ↓
コスト: 90%削減
スケーラビリティ: 向上

教訓:
「全てマイクロサービス」は誤り
適材適所
```

---

**Segment（2020年）**:
```
背景:
- 140以上のマイクロサービス
- 管理の複雑さが限界

解決:
一部をモノリスに統合
  ↓
サービス数: 140 → 40
  ↓
開発速度: 向上
運用負荷: 軽減

教訓:
多ければ良いわけではない
```

---

### モノリスへの戻し方

**パターン1: マージ**:
```
複数の小さなマイクロサービスを統合:

サービスA（ユーザー管理）
サービスB（認証）
サービスC（プロファイル）
  ↓ 統合
アカウントサービス（モノリス）

理由:
- 頻繁に一緒に変更される
- サービス間通信が多い
- 分離のメリットがない
```

**パターン2: 選択的な統合**:
```
コアサービスはモノリス
周辺サービスはマイクロサービス

例:
モノリス:
├─ ユーザー管理
├─ 注文処理
└─ 商品管理

マイクロサービス:
├─ 通知（独立性高い）
├─ レポート（高負荷）
└─ 検索（異なる技術スタック）

ハイブリッド構成
```

---

## まとめ

### 移行の鉄則

```
1. ビジネス価値を明確に
   技術のための移行ではない

2. 段階的に進める
   ビッグバンは避ける

3. リスクの低い部分から
   学習曲線を考慮

4. 組織も同時に変革
   技術だけでは成功しない

5. モニタリングを先に
   問題を早期発見

6. 引き返す勇気
   うまくいかなければ中止も選択肢
```

### 現実的な選択肢

```
選択肢A: モノリス維持
└─ 小規模、シンプルな要件

選択肢B: Modular Monolith
└─ 中規模、将来の拡張性確保

選択肢C: ハイブリッド
└─ 一部のみマイクロサービス化

選択肢D: フルマイクロサービス
└─ 大規模、複雑、高スケーラビリティ要求

多くの場合、BまたはCが最適
```

---

## 参考リンク

- [Strangler Fig Application (Martin Fowler)](https://martinfowler.com/bliki/StranglerFigApplication.html)
- [Monolith to Microservices (Sam Newman)](https://samnewman.io/books/monolith-to-microservices/)
- [Shopify's Modular Monolith](https://shopify.engineering/deconstructing-monolith-designing-software-maximizes-developer-productivity)

**最終更新**: 2026-01-24
