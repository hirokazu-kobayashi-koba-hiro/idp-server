---
sidebar_position: 3
---

# マイクロサービスのデータ管理

---

## 概要

マイクロサービスにおけるデータ管理は、モノリシックアプリケーションとは異なる課題があります。本ドキュメントでは、データの分離、整合性の維持、トランザクション管理について解説します。

---

## Database per Service パターン

### 原則

```
各サービスが専用のデータベースを持つ:

┌─────────────────────────────────────┐
│ サービスA  サービスB  サービスC      │
│    ↓          ↓          ↓          │
│  DB-A       DB-B       DB-C         │
└─────────────────────────────────────┘

ルール:
- サービスは自分のDBにのみアクセス
- 他サービスのDBには直接アクセス禁止
- データ取得はAPI経由
```

---

### データベース技術の選択

```
サービスごとに最適なDBを選択可能:

ユーザーサービス:
└─ PostgreSQL（リレーショナル、トランザクション）

商品カタログサービス:
└─ MongoDB（ドキュメント、柔軟なスキーマ）

セッションサービス:
└─ Redis（インメモリ、高速）

検索サービス:
└─ Elasticsearch（全文検索）

分析サービス:
└─ ClickHouse（列指向、分析特化）

利点: 各サービスの要件に最適
課題: 運用の複雑性
```

---

## 分散トランザクション

### 2フェーズコミット（2PC）

```
コーディネーター主導のトランザクション:

Phase 1 (準備):
コーディネーター → 全サービスに準備要求
各サービス     → 準備OK/NG を返答

Phase 2 (コミット):
全てOKの場合:
  コーディネーター → 全サービスにコミット指示

1つでもNG:
  コーディネーター → 全サービスにロールバック指示

課題:
- パフォーマンス低下
- ブロッキング（準備中は他の操作不可）
- コーディネーターがSPOF
- 実用的でないことが多い
```

---

### Saga パターン

**Choreography（イベント駆動）**:
```
注文処理の例:

1. 注文サービス → 注文作成
   → OrderCreated イベント発行

2. 在庫サービス → イベント受信
   → 在庫引当
   → InventoryReserved イベント発行

3. 決済サービス → イベント受信
   → 決済処理
   → PaymentCompleted イベント発行（成功時）
   → PaymentFailed イベント発行（失敗時）

4. PaymentFailed の場合:
   在庫サービス → 在庫引当解除
   注文サービス → 注文キャンセル

特徴:
- 中央制御なし
- 疎結合
- デバッグが困難
```

---

**Orchestration（中央制御）**:
```
Saga Orchestrator が処理を制御:

Orchestrator:
  ↓
1. 注文サービス: 注文作成
  ↓ 成功
2. 在庫サービス: 在庫引当
  ↓ 成功
3. 決済サービス: 決済処理
  ↓ 失敗
4. 在庫サービス: 在庫引当解除（補償）
5. 注文サービス: 注文キャンセル（補償）

特徴:
- 中央で状態管理
- フローが明確
- Orchestratorが複雑化
```

---

## データ結合の戦略

### API Composition

```
複数サービスからデータを取得して結合:

クライアント要求:
「ユーザーの注文履歴（商品詳細含む）」

API Gateway:
  ↓
1. ユーザーサービス → ユーザー情報取得
  ↓
2. 注文サービス → 注文一覧取得
  ↓
3. 商品サービス → 商品詳細取得（複数）
  ↓
4. データ結合
  ↓
クライアントにレスポンス

課題:
- 複数回のネットワーク呼び出し
- レイテンシの増加
- 部分的な失敗の処理
```

---

### CQRS（Command Query Responsibility Segregation）

```
┌─────────────────────────────────────────┐
│  コマンド側（更新）  │  クエリ側（参照）│
├─────────────────────────────────────────┤
│  注文サービス        │  読み取り専用DB  │
│    ↓                 │    ↑            │
│  書き込みDB          │    │            │
│    ↓                 │    │            │
│  イベント発行 ───────┴────┘            │
│  (OrderCreated等)                       │
│                                         │
│  読み取りDBは非正規化・最適化           │
└─────────────────────────────────────────┘

利点:
- 読み書きの最適化を分離
- クエリパフォーマンス向上
- 複雑な集計クエリに対応

課題:
- 結果整合性（eventual consistency）
- データ同期の遅延
- 複雑性の増加
```

---

## データの整合性

### 結果整合性（Eventual Consistency）

```
マイクロサービスでの一般的なアプローチ:

即座には整合しないが、最終的には整合する

例:
1. 注文作成（注文サービス）
   ↓ イベント発行
2. 在庫更新（在庫サービス）← 数秒遅延
3. 売上集計更新（分析サービス）← 数分遅延

状態:
T+0秒: 注文は作成済み、在庫はまだ古い値
T+5秒: 在庫も更新済み、分析はまだ古い値
T+60秒: 全て整合

許容できる場合:
- リアルタイム性が不要
- ビジネス的に許容範囲

許容できない場合:
- 金融取引
- 在庫引当（二重販売防止）
→ 同期処理または分散ロック
```

---

## データ複製の戦略

### 読み取り専用レプリカ

```
サービス間でデータをコピー:

マスター: ユーザーサービス
  ↓ イベント
コピー: 注文サービス内のユーザー情報（読み取り専用）

利点:
- API呼び出し不要
- 高速なローカル読み取り
- 可用性向上

課題:
- データの重複
- 同期の遅延
- 更新時の不整合リスク

使用場面:
- 頻繁に参照されるマスターデータ
- リアルタイム性が不要
```

---

## 参照データの管理

### Shared Database（アンチパターン）

```
❌ 避けるべき:
サービスA ─┐
           ├─→ 共有DB
サービスB ─┘

問題:
- サービスの独立性喪失
- スキーマ変更の影響が全サービスに
- デプロイの結合
- データベースがボトルネック
```

---

### Reference Data Service

```
✓ 推奨:
┌──────────────────┐
│ 参照データサービス│
│ (国コード、通貨等)│
└────────┬─────────┘
         │ API
    ┌────┼────┬─────┐
    ↓    ↓    ↓     ↓
  SvcA SvcB SvcC  SvcD

利点:
- マスターデータの一元管理
- 更新の統制
- キャッシュ可能
```

---

## まとめ

### データ管理の原則

```
1. Database per Service
   各サービスが専用DBを持つ

2. API経由でのアクセス
   他サービスのDBに直接アクセスしない

3. 結果整合性の受容
   即座の整合性は困難、最終的な整合を目指す

4. Saga パターン
   分散トランザクションの実装

5. データ複製の戦略
   必要に応じて読み取り専用コピーを保持
```

---

## 次のステップ

- [04-observability.md](./04-observability.md) - 観測性とモニタリング
- [05-deployment.md](./05-deployment.md) - デプロイ戦略

---

## 参考リンク

- [Saga Pattern](https://microservices.io/patterns/data/saga.html)
- [CQRS Pattern](https://martinfowler.com/bliki/CQRS.html)
- [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)

**最終更新**: 2026-01-24
