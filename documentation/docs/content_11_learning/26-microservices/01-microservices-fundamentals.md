---
sidebar_position: 1
---

# マイクロサービスアーキテクチャの基礎

---

## 概要

マイクロサービスアーキテクチャは、アプリケーションを小さな独立したサービス群として構築するアーキテクチャパターンです。本ドキュメントでは、マイクロサービスの基本概念、特徴、アーキテクチャパターンを解説します。

---

## マイクロサービスとは

### 定義

```
マイクロサービス:
ビジネス機能ごとに独立してデプロイ可能な
小さなサービス群で構成されたアーキテクチャ

特徴:
├─ サービスの独立性
├─ 独自のデータストア
├─ 独立したデプロイ
├─ 疎結合
└─ 自律的なチーム
```

---

### アーキテクチャの比較

**モノリシック（一枚岩）**:
```
┌─────────────────────────────────────────┐
│         単一アプリケーション              │
├─────────────────────────────────────────┤
│  UI層                                   │
│  ビジネスロジック層                      │
│  データアクセス層                        │
│  ↓                                      │
│  単一データベース                        │
└─────────────────────────────────────────┘

デプロイ: アプリ全体を一括
スケーリング: 全体を複製
データベース: 共有
```

---

**マイクロサービス**:
```
┌────────┐  ┌────────┐  ┌────────┐
│サービスA│  │サービスB│  │サービスC│
│  ↓     │  │  ↓     │  │  ↓     │
│ DB-A   │  │ DB-B   │  │ DB-C   │
└────────┘  └────────┘  └────────┘

デプロイ: サービスごとに独立
スケーリング: 必要なサービスのみ
データベース: サービスごとに分離
```

---

## マイクロサービスの特徴

### 1. サービスの独立性

```
各サービスの特徴:

独立したプロセス:
├─ 独自のランタイム
├─ 独立したメモリ空間
└─ プロセス間通信（HTTP、gRPC等）

独立したデータストア:
├─ サービス専用DB
├─ 他サービスから直接アクセス不可
└─ API経由でデータ取得

独立したデプロイ:
├─ 他サービスに影響なく更新
├─ 独自のリリースサイクル
└─ ダウンタイムなし更新可能
```

---

### 2. 技術スタックの多様性

```
サービスごとに最適な技術を選択可能:

サービスA（API Gateway）:
└─ Node.js + Express

サービスB（認証）:
└─ Java + Spring Boot

サービスC（通知）:
└─ Python + FastAPI

サービスD（分析）:
└─ Go + gRPC

利点: 各サービスに最適な技術
制約: 運用の複雑さ増加
```

---

### 3. 組織との整合性

**コンウェイの法則**:
```
「システム設計は組織構造を反映する」

マイクロサービス向きの組織:
┌─────────────────────────────────────┐
│  サービスA    サービスB    サービスC  │
│     ↓            ↓            ↓      │
│  チームA      チームB      チームC    │
│  (3-8人)      (3-8人)      (3-8人)   │
│                                       │
│  各チームが独立して開発・運用          │
└─────────────────────────────────────┘

モノリス向きの組織:
└─ 1つの大きなチーム
```

---

## マイクロサービスのパターン

### 1. API Gateway パターン

```
┌─────────────────────────────────────────┐
│          API Gateway                    │
│  (リクエストのルーティング、認証等)      │
└──────┬─────────┬─────────┬─────────┘
       │         │         │
   ┌───▼───┐ ┌───▼───┐ ┌───▼───┐
   │ユーザー│ │注文    │ │商品    │
   │サービス│ │サービス│ │サービス│
   └───────┘ └───────┘ └───────┘

役割:
- 単一エントリーポイント
- ルーティング
- 認証・認可
- レート制限
- レスポンス集約
```

---

### 2. Backend for Frontend (BFF) パターン

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│Web UI   │  │Mobile   │  │Admin    │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
┌────▼────┐  ┌───▼────┐  ┌───▼────┐
│Web BFF  │  │Mobile  │  │Admin   │
│         │  │BFF     │  │BFF     │
└────┬────┘  └───┬────┘  └───┬────┘
     │           │           │
     └───────┬───┴───────────┘
             │
     ┌───────▼───────┐
     │ バックエンド    │
     │ サービス群      │
     └────────────────┘

利点:
- クライアントごとに最適化されたAPI
- フロントエンドチームが BFF を管理
```

---

### 3. サービスメッシュパターン

```
サービス間通信の制御層:

サービスA ←→ Sidecar Proxy
                ↕
            Service Mesh
            (Istio, Linkerd等)
                ↕
サービスB ←→ Sidecar Proxy

機能:
├─ サービス間認証（mTLS）
├─ トラフィック管理
├─ 障害復旧（リトライ、サーキットブレーカー）
├─ 観測性（トレーシング、メトリクス）
└─ セキュリティポリシー
```

---

## データ管理

### Database per Service パターン

**原則**: 各サービスが専用のデータベースを持つ

```
┌──────────────────────────────────────┐
│ サービスA  │  サービスB  │  サービスC│
│    ↓       │    ↓       │    ↓      │
│  DB-A      │  DB-B      │  DB-C     │
│ (PostgreSQL)│ (MongoDB)  │ (Redis)   │
└──────────────────────────────────────┘

利点:
✓ サービスの独立性
✓ 技術選択の自由
✓ スケーラビリティ

課題:
⚠ データ整合性の維持
⚠ トランザクション管理
⚠ データ結合の困難
```

---

### Saga パターン（分散トランザクション）

```
複数サービスにまたがるトランザクションの管理:

注文処理の例:

1. 注文サービス: 注文作成
   ↓ 成功
2. 在庫サービス: 在庫引当
   ↓ 成功
3. 決済サービス: 決済処理
   ↓ 失敗
4. 在庫サービス: 在庫引当解除（補償トランザクション）
5. 注文サービス: 注文キャンセル（補償トランザクション）

実装方式:
- Choreography（イベント駆動）
- Orchestration（中央制御）
```

---

### CQRS パターン

```
Command Query Responsibility Segregation

┌─────────────────────────────────────┐
│  コマンド（更新）    クエリ（参照） │
│      ↓                  ↓           │
│  書き込みDB          読み取りDB     │
│  (正規化)            (非正規化)     │
│      ↓                  ↑           │
│      └─── イベント ─────┘           │
└─────────────────────────────────────┘

利点:
- 読み書きの最適化を独立して実施
- スケーリング戦略を分離
- 複雑なクエリのパフォーマンス向上
```

---

## サービス間通信

### 同期通信（REST / gRPC）

**REST API**:
```
サービスA → HTTP/JSON → サービスB
                          ↓
                       レスポンス
                          ↓
サービスA ← HTTP/JSON ← サービスB

特徴:
✓ シンプル
✓ 広く使われている
⚠ 結合度がやや高い
⚠ レスポンスを待つ必要
```

**gRPC**:
```
サービスA → Protocol Buffers → サービスB

特徴:
✓ 高速（バイナリ）
✓ 型安全
✓ 双方向ストリーミング
⚠ デバッグがやや困難
```

---

### 非同期通信（メッセージング）

**イベント駆動アーキテクチャ**:
```
サービスA → イベント発行 → メッセージブローカー
                              (Kafka, RabbitMQ等)
                                      ↓
                              サービスB（購読）
                              サービスC（購読）

特徴:
✓ 疎結合
✓ スケーラブル
✓ 障害の分離
⚠ 複雑性の増加
⚠ デバッグの困難
```

---

## サービス分割戦略

### ドメイン駆動設計（DDD）による分割

```
境界づけられたコンテキスト（Bounded Context）:

ECサイトの例:
┌─────────────────────────────────────┐
│  カタログコンテキスト                │
│  └─ 商品サービス                    │
├─────────────────────────────────────┤
│  注文コンテキスト                    │
│  └─ 注文サービス                    │
├─────────────────────────────────────┤
│  在庫コンテキスト                    │
│  └─ 在庫サービス                    │
├─────────────────────────────────────┤
│  顧客コンテキスト                    │
│  └─ 顧客サービス                    │
└─────────────────────────────────────┘

分割の基準:
- ビジネス機能の境界
- 変更頻度
- スケーリング要件
- チーム構造
```

---

### 分割のアンチパターン

**過度な分割**:
```
❌ 悪い例:
├─ ユーザー取得サービス
├─ ユーザー作成サービス
├─ ユーザー更新サービス
└─ ユーザー削除サービス

問題: CRUD ごとに分割（意味がない）

✓ 良い例:
└─ ユーザー管理サービス
    └─ CRUD を含む凝集度の高い機能
```

**技術による分割**:
```
❌ 悪い例:
├─ データベースサービス
├─ キャッシュサービス
└─ UI サービス

問題: 技術層で分割（ビジネス価値が不明確）

✓ 良い例:
ビジネス機能で分割
```

---

## デプロイと運用

### コンテナ化

```
各サービスをコンテナでパッケージ:

サービスA:
├─ Dockerfile
├─ アプリケーションコード
├─ 依存ライブラリ
└─ 設定ファイル
   ↓
Docker Image
   ↓
コンテナとして実行

利点:
- 環境の一貫性
- 軽量
- 高速な起動
```

---

### オーケストレーション（Kubernetes）

```
┌─────────────────────────────────────────┐
│           Kubernetes Cluster            │
├─────────────────────────────────────────┤
│  Pod (サービスA) × 3                    │
│  Pod (サービスB) × 5                    │
│  Pod (サービスC) × 2                    │
│                                         │
│  機能:                                   │
│  ├─ 自動スケーリング                    │
│  ├─ ヘルスチェック                      │
│  ├─ 自動復旧                            │
│  ├─ ロードバランシング                  │
│  └─ ローリングアップデート              │
└─────────────────────────────────────────┘
```

---

## マイクロサービスのメリット

```
技術的メリット:
├─ 独立したデプロイ（リリース頻度向上）
├─ 技術スタックの自由度
├─ 部分的なスケーリング
├─ 障害の分離
└─ 段階的な書き換え

組織的メリット:
├─ チームの自律性
├─ 並行開発の容易さ
├─ 責任範囲の明確化
└─ スキル特化
```

---

## マイクロサービスの課題

```
技術的課題:
├─ 分散システムの複雑性
├─ ネットワークレイテンシ
├─ データ整合性の維持
├─ トランザクション管理
├─ デバッグの困難
└─ テストの複雑化

運用的課題:
├─ モニタリング（複数サービス）
├─ ログの集約
├─ デプロイの複雑性
├─ インフラコスト
└─ 学習曲線

組織的課題:
├─ チーム間の調整
├─ API契約の管理
├─ スキルセットの要求
└─ DevOps 文化の必要性
```

---

## いつマイクロサービスを選ぶべきか

### 適している状況

```
✓ 大規模チーム（20人以上）
✓ 明確なドメイン境界
✓ 部分的に高負荷な機能
✓ 頻繁なデプロイが必要
✓ 技術的多様性が必要
✓ 組織がDevOpsに成熟
```

---

### 適していない状況

```
⚠ 小規模チーム（5人以下）
⚠ ドメイン境界が不明確
⚠ スタートアップ（迅速な変更が必要）
⚠ 運用リソース不足
⚠ DevOps 経験不足
⚠ 単純なCRUDアプリ
```

---

### トレードオフの評価

```
マイクロサービス採用の判断基準:

メリット > コスト の場合のみ採用

コスト:
├─ インフラコスト（複数DB、メッセージブローカー等）
├─ 開発コスト（分散システムの複雑性）
├─ 運用コスト（モニタリング、デプロイ等）
└─ 学習コスト（チームのスキルアップ）

メリット:
├─ スケーラビリティの向上
├─ デプロイ頻度の向上
├─ 障害の分離
└─ チームの自律性

小規模なら: モノリス
大規模なら: マイクロサービス検討
中規模なら: Modular Monolith
```

---

## Modular Monolith（中間解）

### 概念

```
┌─────────────────────────────────────────┐
│        Modular Monolith                 │
│  (モジュール化されたモノリス)            │
├─────────────────────────────────────────┤
│  モジュールA  │  モジュールB  │  モジュールC│
│  (疎結合)    │  (疎結合)    │  (疎結合)  │
│              │              │            │
│  ↓────────────┴──────────────┴──────↓   │
│           単一データベース                │
└─────────────────────────────────────────┘

特徴:
- モノリスのシンプルさ
- マイクロサービスへの移行パス
- モジュール境界を明確に
```

---

### 移行戦略

```
フェーズ1: Modular Monolith
├─ モジュール境界を設計
├─ 疎結合を維持
└─ 単一アプリとしてデプロイ

フェーズ2: 段階的分離
├─ 高負荷なモジュールから分離
├─ 1つずつマイクロサービス化
└─ リスクを最小化

フェーズ3: マイクロサービス
└─ 必要な部分のみ分離
    不要なら Modular Monolith 継続
```

---

## まとめ

### マイクロサービスの本質

```
マイクロサービスは銀の弾丸ではない

適切な状況:
- 大規模
- 複雑
- 高いスケーラビリティ要求
- 成熟した組織

不適切な状況:
- 小規模
- シンプル
- リソース制約
- 組織の未成熟

重要なのは:
「マイクロサービス」という名前ではなく
ビジネス要件を満たすアーキテクチャ
```

---

## 次のステップ

- [02-service-communication.md](./02-service-communication.md) - サービス間通信パターン
- [03-data-management.md](./03-data-management.md) - データ管理戦略
- [04-observability.md](./04-observability.md) - 観測性とモニタリング

---

## 参考リンク

- [Building Microservices (Sam Newman)](https://samnewman.io/books/building_microservices/)
- [Microservices.io](https://microservices.io/)
- [Martin Fowler - Microservices](https://martinfowler.com/articles/microservices.html)

**最終更新**: 2026-01-24
