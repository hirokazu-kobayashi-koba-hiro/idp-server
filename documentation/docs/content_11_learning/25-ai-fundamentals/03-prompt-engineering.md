---
sidebar_position: 3
---

# プロンプトエンジニアリング入門

---

## 概要

プロンプトエンジニアリングは、LLMから望ましい出力を得るための指示文設計技術です。適切なプロンプトは、モデルの性能を最大限引き出し、ハルシネーションを減らし、タスク精度を向上させます。

---

## プロンプトの基本構造

### 標準的なプロンプトテンプレート

```
┌─────────────────────────────────────────┐
│       プロンプトの4要素                  │
├─────────────────────────────────────────┤
│  1️⃣ ロール（Role）                       │
│     "あなたは〇〇の専門家です"           │
│                                         │
│  2️⃣ コンテキスト（Context）              │
│     背景情報、制約条件                   │
│                                         │
│  3️⃣ タスク（Task）                       │
│     具体的な指示                         │
│                                         │
│  4️⃣ フォーマット（Format）               │
│     出力形式の指定                       │
└─────────────────────────────────────────┘
```

---

**実例**:
```
あなたはセキュリティ専門家です。           ← ロール

以下のコードにはSQLインジェクションの       ← コンテキスト
脆弱性が含まれている可能性があります。

このコードの脆弱性を特定し、                ← タスク
修正方法を提案してください。

出力形式:                                  ← フォーマット
1. 脆弱性の説明
2. 修正後のコード
3. 追加の推奨事項

[コード]
query = f"SELECT * FROM users WHERE id = {user_id}"
```

---

## プロンプト設計の原則

### 1. 明確性（Clarity）

**❌ 曖昧なプロンプト**:
```
"Pythonについて教えて"
```
→ 何について? どのレベル? どの程度の詳しさ?

**✅ 明確なプロンプト**:
```
"Python初学者向けに、リスト内包表記の基本文法を
コード例3つと説明を含めて解説してください。
各例は難易度順に並べてください。"
```

---

### 2. 具体性（Specificity）

**❌ 抽象的**:
```
"良いコードを書いて"
```

**✅ 具体的**:
```
"以下の要件を満たすPython関数を実装してください:
- 関数名: validate_email
- 引数: email (str)
- 戻り値: bool（有効なら True）
- 検証項目: @の存在、ドメイン形式
- エラーハンドリング: ValueError を発生
- 型ヒント付き
- docstring含む"
```

---

### 3. 制約の明示（Constraints）

**制約の種類**:

```python
# 長さ制約
"200文字以内で要約してください"

# スタイル制約
"箇条書きで、各項目は動詞で始めてください"

# 知識範囲制約
"Python 3.11 の公式ドキュメントに基づいて回答してください"

# 禁止事項
"推測を含めず、不明な場合は『わかりません』と答えてください"
```

---

## 高度なプロンプト技法

### 1. Few-Shot Learning（数例学習）

**コンセプト**: 例示で期待する出力パターンを示す

```
┌─────────────────────────────────────────┐
│      Zero-Shot vs Few-Shot              │
├─────────────────────────────────────────┤
│  Zero-Shot（例なし）                     │
│  "この文を敬語に変換してください"        │
│  入力: "今日は休みだ"                    │
│  → 出力品質: 不安定                     │
│                                         │
│  Few-Shot（例あり）                      │
│  例1: "明日会う" → "明日お会いします"   │
│  例2: "資料を見た" → "資料を拝見しました"│
│  入力: "今日は休みだ"                    │
│  → 出力: "本日はお休みです"（高品質）   │
└─────────────────────────────────────────┘
```

---

**実用例: コミットメッセージ生成**
```
以下の例に従って、変更内容からコミットメッセージを生成してください。

例1:
変更: ユーザー認証APIエンドポイント追加
メッセージ: "feat: add user authentication endpoint"

例2:
変更: NullPointerException修正
メッセージ: "fix: resolve NPE in UserService.findById"

例3:
変更: README更新、インストール手順追加
メッセージ: "docs: update README with installation steps"

---
変更内容: パスワード検証ロジック強化、8文字以上必須に変更

期待される出力:
"feat: enhance password validation to require 8+ characters"
```

---

### 2. Chain of Thought (CoT) - 思考の連鎖

**原理**: 推論ステップを明示させることで精度向上

```
┌─────────────────────────────────────────┐
│     通常プロンプト vs CoT                │
├─────────────────────────────────────────┤
│  通常:                                  │
│  Q: "リンゴ5個とオレンジ3個買いました。 │
│      1個50円です。合計いくらですか?"    │
│  A: "400円です"                         │
│      ↑ 誤答（計算ミス）                 │
│                                         │
│  CoT:                                   │
│  Q: "ステップバイステップで考えてください"│
│  A: "1. リンゴ5個 + オレンジ3個 = 8個   │
│      2. 8個 × 50円 = 400円              │
│      答え: 400円です"                   │
│      ↑ 推論過程が可視化される           │
└─────────────────────────────────────────┘
```

---

**プロンプト例**:
```
以下の問題を段階的に解いてください。
各ステップで何を考えているか説明してください。

問題:
あるWebサービスのユーザー数は毎月20%増加しています。
現在1000人のユーザーがいます。
6ヶ月後のユーザー数は何人ですか?
（小数点以下切り捨て）

回答形式:
ステップ1: [計算式と説明]
ステップ2: [計算式と説明]
...
最終答え: [数値]
```

---

### 3. Self-Consistency（自己一貫性）

**手法**: 複数回推論させて多数決

```
┌─────────────────────────────────────────┐
│      Self-Consistency の流れ            │
├─────────────────────────────────────────┤
│  質問: "この契約書の主要リスクは?"      │
│         ↓                               │
│  推論1（Temperature=0.7）:              │
│    "解約条項が厳しい"                   │
│         ↓                               │
│  推論2（Temperature=0.7）:              │
│    "解約条項が厳しい"                   │
│         ↓                               │
│  推論3（Temperature=0.7）:              │
│    "賠償責任範囲が不明確"               │
│         ↓                               │
│  多数決: "解約条項が厳しい" を採用      │
└─────────────────────────────────────────┘
```

**実装例**（疑似コード）:
```python
def self_consistency(prompt, n=5):
    answers = []
    for i in range(n):
        response = llm.generate(prompt, temperature=0.7)
        answers.append(response)

    # 最頻出回答を選択
    return max(set(answers), key=answers.count)
```

---

### 4. Tree of Thoughts（思考の木）

**概念**: 複数の推論パスを探索

```
                    質問
                     │
        ┌────────────┼────────────┐
        │            │            │
     アプローチA   アプローチB   アプローチC
        │            │            │
    ┌───┴───┐    ┌───┴───┐    ┌───┴───┐
  ステップ1 ステップ1' ステップ1" ...
    │            │            │
  評価         評価         評価
    │            │            ↓
  続行         続行        破棄（低スコア）
```

**プロンプト例**:
```
以下のバグ修正について、3つの異なるアプローチを提案し、
それぞれの長所・短所を評価してください。
最後に最適なアプローチを選択してください。

バグ: ユーザーが同時ログインすると session_id が衝突する

出力形式:
アプローチ1: [説明]
  長所: [...]
  短所: [...]
  スコア: [1-10]

アプローチ2: [説明]
  ...

最終選択: アプローチ[番号] - 理由: [...]
```

---

### 5. Role Prompting（ロールプレイ）

**効果**: 専門性の高い回答を引き出す

```
❌ ロールなし:
"OAuth 2.0の脆弱性を教えて"

✅ ロールあり:
"あなたは10年の経験を持つセキュリティ監査人です。
OWASP Top 10に精通しており、過去に50社以上の
OAuth実装を監査した経験があります。

OAuth 2.0実装における上位3つのセキュリティリスクを、
実際の攻撃シナリオと対策を含めて説明してください。"
```

---

**ロールの種類**:

| ロール | 用途 |
|--------|------|
| **専門家** | "セキュリティ専門家", "データサイエンティスト" |
| **教師** | "初学者向けに説明する教師" |
| **レビュアー** | "厳格なコードレビュアー" |
| **デバッガー** | "バグ追跡の専門家" |
| **アーキテクト** | "システムアーキテクト" |

---

## タスク別プロンプトパターン

### 1. コード生成

**テンプレート**:
```
[言語] で [機能] を実装してください。

要件:
- [詳細要件1]
- [詳細要件2]
- [詳細要件3]

制約:
- [ライブラリ制約]
- [パフォーマンス要件]

出力:
1. 完全な実装コード
2. 使用例
3. エッジケースの処理説明
```

**実例**:
```
Python で JWT トークン検証関数を実装してください。

要件:
- RS256 アルゴリズム対応
- 有効期限チェック
- 発行者（issuer）検証
- 型ヒント完備

制約:
- PyJWT ライブラリ使用
- 例外は JWTError を継承したカスタム例外

出力:
1. 関数実装（docstring含む）
2. テストケース3つ
3. エラーハンドリングの説明
```

---

### 2. コードレビュー

**テンプレート**:
```
以下のコードをレビューしてください。

観点:
- セキュリティ（OWASP準拠）
- パフォーマンス
- 可読性
- エラーハンドリング
- テスト容易性

[コード]

出力形式:
## 重大な問題（Critical）
- [問題点と修正案]

## 改善推奨（Recommended）
- [改善点]

## 良い点（Good）
- [評価できる点]
```

---

### 3. デバッグ支援

**テンプレート**:
```
以下のエラーをデバッグしてください。

環境:
- 言語: [...]
- フレームワーク: [...]
- 依存関係: [...]

エラーメッセージ:
```
[エラー全文]
```

関連コード:
```
[コードスニペット]
```

期待される動作: [...]
実際の動作: [...]

出力:
1. 根本原因の特定
2. 修正方法
3. 再発防止策
```

---

### 4. ドキュメント生成

**API仕様書生成**:
```
以下のREST APIエンドポイントの仕様書を
OpenAPI 3.0形式で生成してください。

エンドポイント: POST /api/v1/users
機能: 新規ユーザー登録

リクエストボディ:
- email (string, required): メールアドレス
- password (string, required): 8文字以上
- name (string, optional): 表示名

レスポンス:
- 成功時（201）: ユーザーオブジェクト
- 失敗時（400）: バリデーションエラー
- 失敗時（409）: メール重複

セキュリティ: Bearer Token 認証

出力: YAML形式のOpenAPI仕様
```

---

### 5. テストケース生成

**テンプレート**:
```
以下の関数のテストケースを網羅的に生成してください。

[関数コード]

カバレッジ:
- 正常系（Happy Path）
- 境界値（Boundary）
- 異常系（Error Cases）
- エッジケース

フレームワーク: pytest
出力: テストコード全文
```

---

## 実践的なプロンプト最適化

### 1. 反復的改善プロセス

```
┌─────────────────────────────────────────┐
│     プロンプト改善サイクル               │
├─────────────────────────────────────────┤
│  1. 初期プロンプト作成                  │
│       ↓                                 │
│  2. 実行・評価                          │
│       ↓                                 │
│  3. 問題点特定                          │
│     - 不正確な回答?                     │
│     - フォーマット不一致?               │
│     - ハルシネーション?                 │
│       ↓                                 │
│  4. プロンプト修正                      │
│     - 例追加                            │
│     - 制約明確化                        │
│     - CoT導入                           │
│       ↓                                 │
│  5. 再実行（1に戻る）                   │
└─────────────────────────────────────────┘
```

---

### 2. A/Bテスト

**比較例**:
```python
# バージョンA（シンプル）
prompt_a = "このコードのバグを修正してください"

# バージョンB（詳細）
prompt_b = """
以下のコードにはNullPointerExceptionが発生するバグがあります。
バグを特定し、修正したコードと説明を提供してください。

出力:
1. バグの箇所（行番号）
2. 原因の説明
3. 修正後のコード
"""

# 複数のケースで精度を比較
test_cases = [...]
accuracy_a = evaluate(prompt_a, test_cases)  # 60%
accuracy_b = evaluate(prompt_b, test_cases)  # 85%
```

---

### 3. プロンプトチェーニング

**複雑タスクを分解**:
```
┌─────────────────────────────────────────┐
│      単一プロンプト vs チェーニング      │
├─────────────────────────────────────────┤
│  単一（複雑で不安定）:                  │
│  "この論文を要約して、重要な図表を      │
│   抽出し、批判的分析を加えてください"   │
│                                         │
│  チェーニング（安定）:                  │
│  Step 1: "この論文を500文字で要約"      │
│      ↓                                  │
│  Step 2: "要約から重要な図表3つ抽出"    │
│      ↓                                  │
│  Step 3: "図表を基に批判的分析を記述"   │
└─────────────────────────────────────────┘
```

**実装例**:
```python
def analyze_paper(paper_text):
    # ステップ1: 要約
    summary_prompt = f"以下の論文を500文字で要約:\n{paper_text}"
    summary = llm.generate(summary_prompt)

    # ステップ2: 図表抽出
    figure_prompt = f"以下の要約から重要な図表3つを抽出:\n{summary}"
    figures = llm.generate(figure_prompt)

    # ステップ3: 批判的分析
    analysis_prompt = f"""
    要約: {summary}
    図表: {figures}

    上記を基に、この論文の強みと弱みを分析してください。
    """
    analysis = llm.generate(analysis_prompt)

    return {"summary": summary, "figures": figures, "analysis": analysis}
```

---

## プロンプトのアンチパターン

### ❌ 避けるべきパターン

**1. 曖昧な指示**
```
"良い感じにして"
"適当に修正して"
```

**2. 複数タスクの混在**
```
"このコードをリファクタリングして、
テストも書いて、
ドキュメントも追加して、
パフォーマンスも改善して"

→ 一度に1つのタスクに集中
```

**3. 暗黙的期待**
```
"このAPIを実装して"

→ エラーハンドリング、認証、ログ、レート制限など
  暗黙の期待を明示する
```

**4. 過度に長い指示**
```
3000文字のプロンプト

→ 重要な指示が埋もれる
→ 簡潔に、または構造化
```

---

## プロンプトテンプレート集

### 1. セキュリティレビュー

```markdown
# セキュリティレビュー

あなたはOWASP Top 10に精通したセキュリティエンジニアです。

## 対象コード
```
[コード]
```

## レビュー観点
- [ ] 入力検証（SQLインジェクション、XSS等）
- [ ] 認証・認可の適切性
- [ ] 機密情報の扱い（ログ、エラーメッセージ）
- [ ] セッション管理
- [ ] CSRF対策

## 出力形式
### 🔴 Critical（即対応必須）
- [脆弱性と修正方法]

### 🟡 Warning（推奨）
- [改善推奨事項]

### ✅ Good Practices
- [評価できる点]
```

---

### 2. パフォーマンス分析

```markdown
以下のコードのパフォーマンスボトルネックを特定し、
最適化を提案してください。

## コード
```
[コード]
```

## 前提条件
- データ規模: [...]
- 実行環境: [...]
- 性能要件: [...]

## 分析視点
1. 時間計算量（Big O）
2. 空間計算量
3. N+1クエリ問題
4. 不要な計算の繰り返し
5. キャッシュ可能性

## 出力
1. ボトルネック特定（行番号付き）
2. 最適化後のコード
3. 性能改善見込み（O(n²) → O(n) など）
```

---

### 3. リファクタリング

```markdown
以下のコードをClean Codeの原則に従って
リファクタリングしてください。

## 対象コード
```
[コード]
```

## リファクタリング観点
- Single Responsibility Principle
- 関数の分割（1関数20行以内目標）
- 命名の改善
- マジックナンバー排除
- 重複コード削減

## 制約
- 既存の外部インターフェースは変更しない
- テストが通ること

## 出力
1. リファクタリング後のコード
2. 変更点の説明（箇条書き）
3. 改善効果（可読性、保守性等）
```

---

## まとめ

### プロンプトエンジニアリングの核心

```
┌─────────────────────────────────────────┐
│      効果的なプロンプトの条件            │
├─────────────────────────────────────────┤
│  ✅ 明確（何をすべきか具体的）           │
│  ✅ 完全（必要な情報をすべて含む）       │
│  ✅ 構造化（読みやすいフォーマット）     │
│  ✅ 制約明示（やってはいけないことも）   │
│  ✅ 例示（Few-Shot）                     │
│  ✅ 検証可能（出力が評価できる）         │
└─────────────────────────────────────────┘
```

### ベストプラクティス

1. **反復的改善**: 一度で完璧を目指さず、試行錯誤
2. **テンプレート化**: 再利用可能なパターンを蓄積
3. **Few-Shotの活用**: 例示で品質向上
4. **タスク分解**: 複雑な処理はチェーニング
5. **評価指標設定**: 主観でなくデータで判断

---

## 次のステップ

- [04-rag-architecture.md](./04-rag-architecture.md) - RAGで知識を拡張
- [05-ai-agents.md](./05-ai-agents.md) - プロンプトを超えた自律エージェント
- [06-modern-ai-tools.md](./06-modern-ai-tools.md) - 実用ツール比較

---

## 参考リンク

- [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)
- [Anthropic Prompt Library](https://docs.anthropic.com/claude/prompt-library)
- [Tree of Thoughts論文](https://arxiv.org/abs/2305.10601)
- [Chain of Thought論文](https://arxiv.org/abs/2201.11903)
